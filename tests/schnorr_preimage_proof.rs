use rand::RngCore;
use rand::rngs::OsRng;
use curve25519_dalek::{ristretto::RistrettoPoint, scalar::Scalar};
use lox_zkp::toolbox::sigma::{SigmaProtocol, GroupMorphism, SchnorrPreimage};

// The group endomorphism (on curve25519_dalek) : P -> coeff * P 
pub struct MulFunction {
    pub coeff: Scalar,
}

impl GroupMorphism for MulFunction {
    type Domain = RistrettoPoint;
    type Codomain = RistrettoPoint;

    fn map(&self, x: &Self::Domain) -> Self::Codomain {
        self.coeff * x
    }
}

#[allow(non_snake_case)]
#[test]
fn schnorr_preimage_test_without_fiatshamir() {
    let mut rng = OsRng;

    // Setup: Base point for group morphism
    let h = Scalar::random(&mut rng);

    // Setup the group morphism (ExpFunction who implements GroupMorphism)
    let f = MulFunction {coeff: h};

    // Private/public key
    let x = RistrettoPoint::random(&mut rng);
    let y = f.map(&x);

    // Setup the sigma protocol (SchnorrPreimage who implements SigmaProtocol)
    let preimage_protocol = SchnorrPreimage {morphism: f, target: y};

    // Commitment
    let (R, prover_state) = preimage_protocol.prover_commit(&x, &mut rng);

    // Challenge generated by verifier
    let challenge: u64 = rng.next_u64();

    // Prover response
    let response = preimage_protocol.prover_response(&prover_state, &challenge);

    let result = preimage_protocol.verifier(&R, &challenge, &response);

    assert!(result);
}